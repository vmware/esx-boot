/*******************************************************************************
 * Copyright (c) 2008-2024 Broadcom. All Rights Reserved.
 * The term "Broadcom" refers to Broadcom Inc. and/or its subsidiaries.
 * All rights reserved.
 * SPDX-License-Identifier: GPL-2.0
 ******************************************************************************/

/*
 * safeboot.c -- Safeboot module
 *
 *   safeboot [-rsSVf] [-m <FILEPATH>]
 *
 *      OPTIONS
 *         -m <FILEPATH>  Next loader path
 *         -r             Force rollback (not used on UEFI systems)
 *         -S <1...4>     Set the default serial port (1=COM1, 2=COM2, 3=COM3,
 *                        4=COM4, 0xNNNN=hex I/O port address ).
 *         -s <BAUDRATE>  Set the serial port speed to BAUDRATE (in bits per
 *                        second).
 *         -V             Verbose mode
 *         -f             Fake an error when writing to bootstate.
 *
 *   Other options are passed through to mboot.
 */

#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <ctype.h>
#include <boot_services.h>
#include "safeboot.h"

#define DEFAULT_PROG_NAME       "safeboot.c32"

safeboot_env_t safeboot;

static bool shift_r = false;

/*-- safeboot_init -------------------------------------------------------------
 *
 *      Parse safeboot command line options.
 *
 * Parameters
 *      IN argc: number of command line arguments
 *      IN argv: pointer to the command line arguments array
 *
 * Results
 *      ERR_SUCCESS, or a generic error status.
 *----------------------------------------------------------------------------*/
static int safeboot_init(int argc, char **argv)
{
   int opt;
   char *extra, *tmp;

   memset(&safeboot, 0, sizeof (safeboot_env_t));

   if (argc == 0 || argv == NULL || argv[0] == NULL) {
      return ERR_INVALID_PARAMETER;
   }

   safeboot.self_path = strdup((*argv[0] != '\0') ? argv[0] :
                               DEFAULT_PROG_NAME);
   if (safeboot.self_path == NULL) {
      return ERR_OUT_OF_RESOURCES;
   }

   safeboot.serial_com = DEFAULT_SERIAL_COM;
   safeboot.serial_speed = DEFAULT_SERIAL_BAUDRATE;
   extra = strdup("");
   if (extra == NULL) {
      return ERR_OUT_OF_RESOURCES;
   }

   if (argc > 1) {
      optind = 1;
      do {
         opt = getopt(argc, argv, ":m:rs:S:Vc:t:R:p:E:fN:b:L:A:q:");
         switch (opt) {
            case -1:
               break;
            case 'm':
               safeboot.next_loader = strdup(optarg);
               if (safeboot.next_loader == NULL) {
                  return ERR_OUT_OF_RESOURCES;
               }
               break;
            case 'r':
               shift_r = true;
               break;
            case 'S':
               safeboot.serial = true;
               safeboot.serial_com = strtol(optarg, NULL, 0);
               break;
            case 's':
               if (!is_number(optarg)) {
                  return ERR_SYNTAX;
               }
               safeboot.serial = true;
               safeboot.serial_speed = atoi(optarg);
               break;
            case 'V':
               safeboot.verbose = true;
               break;
            case 'c':
            case 't':
            case 'R':
            case 'p':
            case 'E':
            case 'N':
            case 'b':
            case 'L':
            case 'A':
            case 'q':
               /*
                * Other mboot options that take an argument.  Pass
                * through to mboot after the options that safeboot
                * generates.  If mboot acquires any more options that
                * take an argument, we'll need to add them here and
                * in the last argument to getopt() above.
                *
                * Note: As it happens, -c, -t, -R, and -p are all
                * generated by safeboot, so it's not usually a good
                * idea to override that by specifying them explicitly.
                * Also -N and -b aren't useful when booting from disk.
                */
               tmp = extra;
               if (strchr(optarg, ' ') == NULL) {
                  asprintf(&extra, "%s -%c %s", extra, opt, optarg);
               } else {
                  asprintf(&extra, "%s -%c \"%s\"", extra, opt, optarg);
               }
               free(tmp);
               if (extra == NULL) {
                  return ERR_OUT_OF_RESOURCES;
               }
               break;
            case 'f':
               safeboot.fake_write_err = true;
               break;
            case '?':
               /*
                * Other unknown option; assume no argument and pass
                * through to mboot.
                */
               tmp = extra;
               asprintf(&extra, "%s -%c", extra, optopt);
               free(tmp);
               if (extra == NULL) {
                  return ERR_OUT_OF_RESOURCES;
               }
               break;
            case ':':
            default:
               return ERR_SYNTAX;
         }
      } while (opt != -1);
   }

   /*
    * Pass any non-flag arguments through to mboot.
    */
   while (optind < argc) {
      tmp = extra;
      asprintf(&extra, "%s %s", extra, argv[optind++]);
      free(tmp);
      if (extra == NULL) {
         return ERR_OUT_OF_RESOURCES;
      }
   }
   safeboot.extra_args = extra;

   return ERR_SUCCESS;
}

/*-- main ----------------------------------------------------------------------
 *
 *      Safeboot module main function.
 *
 * Parameters
 *      IN argc: number of command line arguments
 *      IN argv: pointer to the command line arguments array
 *
 * Results
 *      ERR_SUCCESS, or a generic error status.
 *----------------------------------------------------------------------------*/
int main(int argc, char **argv)
{
   bootbank_t *bank;
   key_code_t key;
   int retval, status;

   status = safeboot_init(argc, argv);
   if (status != ERR_SUCCESS) {
      return status;
   }

   status = log_init(safeboot.verbose);
   if (status != ERR_SUCCESS) {
      return status;
   }

   do {
      if (safeboot.serial) {
         serial_log_init(safeboot.serial_com, safeboot.serial_speed);
      }

      /*
       * (Re-)initialize the video display if any. gui_init() return value is
       * ignored, letting headless platforms (with no video adpater) continue
       * booting with graphics disabled.
       */
      gui_init();

      status = get_boot_bank(shift_r, &bank);
      if (status != ERR_SUCCESS) {
         Log(LOG_ERR, "No hypervisor found.\n");
         break;
      }

      retval = ERR_SUCCESS;
      status = chainload(bank, &retval);
      bank_clean();

      if (status != ERR_SUCCESS) {
         Log(LOG_ERR, "Failed to chainload BANK%d.\n", bank->volid);
         break;
      }

      if (retval == ERR_SUCCESS) {
         /*
          * We can only be here if mboot has returned successfully. This can
          * only happen when <SHIFT+R> is pressed from mboot to interrupt the
          * loading process.
          */
         shift_r = true;

         retval = log_init(safeboot.verbose);
      }
   } while (retval == ERR_SUCCESS);

   free(safeboot.next_loader);
   free(safeboot.self_path);

   kbd_waitkey(&key);

   return status;
}
